h1(#StandardLibrary). The OCL Standard Library

This documentation on the OCL Standard Library is auto-generated from the
org.eclipse.ocl.pivot/model/OCL-2.5.oclstdlib that defines
the behaviour of the Pivot evaluator and the Xtext editors. It is similar to the OCL 2.4 functionality.
It is a prototype of functionality for OCL 2.5 where the use of models may eliminate ambiguities.

The library support for the Ecore and UML bindings in Luna has been upgraded so that the available operations
are similar to those documented here for the Pivot binding.

h2(#Precedences). *Precedences*

@NAVIGATION@ > @UNARY@ > @MULTIPLICATIVE@ > @ADDITIVE@ > @RELATIONAL@ > @EQUALITY@ > @AND@ > @OR@ > @XOR@ > @IMPLIES@


h2(#Bag). **@Bag(T)@**

A bag is a collection with duplicates allowed. That is, one object can be an element of a bag many times.
There is no ordering defined on the elements in a bag.
Bag is itself an instance of the metatype BagType.

conformsTo "@Collection(T)@":#Collection

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

True if @self@ and bag contain the same elements, the same number of times.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@excluding(object : OclAny[?]) : Bag(T)@

The bag containing all elements of @self@ apart from all occurrences of object.

@excludingAll(objects : Collection(OclAny)) : Bag(T)@

The bag containing all elements of @self@ apart from all occurrences of all objects.

@flatten(T2)() : Bag(T2)@

Redefines the Collection operation. If the element type is not a collection type, this results in the same bag as @self@.
If the element type is a collection type, the result is the bag containing all the elements of all the recursively flattened elements of @self@.

@including(object : T[?]) : Bag(T)@

The bag containing all elements of @self@ plus object.

@includingAll(objects : Collection(T)) : Bag(T)@

The bag containing all elements of @self@ and objects.

@selectByKind(TT)(type : TT[?]) : Bag(TT)@

@selectByType(TT)(type : TT[?]) : Bag(TT)@

*Iterations*

@closure(i : T[1] | lambda : Lambda T() : Set(T)[?]) : Set(T)@

The closure of applying body transitively to every distinct element of the source collection.

@collect(V)(i : T[?] | lambda : Lambda T() : V[?]) : Bag(V)@

@collectNested(V)(i : T[?] | lambda : Lambda T() : V[?]) : Bag(V)@

The Bag of elements which results from applying body to every member of the source nonordered collection.

@reject(i : T[?] | lambda : Lambda T() : Boolean[1]) : Bag(T)@

The sub-bag of the source bag for which body is @false@.

bc.. 
self->reject(iterator | body) = self->select(iterator | not body)
p. 

.

@select(i : T[?] | lambda : Lambda T() : Boolean[1]) : Bag(T)@

The sub-bag of the source bag for which body is @true@.

bc.. 
self->select(iterator | body) =
self->iterate(iterator; result : Bag(T) = Bag{} |
if body then result->including(iterator)
else result
endif)
p. 



@sortedBy(i : T[?] | lambda : Lambda T() : OclAny[?]) : Sequence(T)@

Results in the Sequence containing all elements of the source collection.
The element for which body has the lowest value comes first, and so on.
The type of the body expression must have the < operation defined.
The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c then a < c).

h2(#Boolean). **@Boolean@**

The standard type Boolean represents the common true/false values.
Boolean is itself an instance of the metatype PrimitiveType (from UML).

conformsTo "@OclAny@":#OclAny

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Returns @true@ if the logical value of @self@ is the same as the numeric value of object2, @false@ otherwise.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Returns @true@ if the logical value of @self@ is the not same as the numeric value of object2, @false@ otherwise.

@allInstances() : Set(OclSelf)@

Returns @Set{false, true}@.

@and(b : Boolean[?]) : Boolean[?] invalidating validating@
precedence: @AND@

@false@ if either @self@ or @b@ is @false@.
Otherwise @invalid@ if either @self@ or @b@ is @invalid@ .
Otherwise @null@ if either @self@ or @b@ is @null@.
Otherwise @true@.

bc.. 
body: if self.oclIsInvalid() then
		        if b.oclIsInvalid() then self
		        elseif b = false then false
		        else self
		        endif
		      elseif self = false then false
		      elseif b.oclIsInvalid() then b
		      elseif b = false then false
		      elseif self = null then null
		      elseif b = null then null
		      else true
		      endif
p. 

@and2(b : Boolean[?]) : Boolean[?]@

@false@ if either @self@ or @b@ is @false@.
Otherwise @true@.

bc.. 
body: if self = false then false
		      elseif b = false then false
		      else true
		      endif
p. 

@implies(b : Boolean[?]) : Boolean[?] invalidating validating@
precedence: @IMPLIES@

@true@ if @self@ is @false@, or if @b@ is @true@.
Otherwise @invalid@ if either @self@ or @b@ is @invalid@.
Otherwise @null@ if either @self@ or @b@ is @null@.
Otherwise @false@.

bc.. 
body: if self.oclIsInvalid() then
		        if b.oclIsInvalid() then self
		        elseif b = true then true
		        else self
		        endif
		      elseif self = false then true
		      elseif b.oclIsInvalid() then b
		      elseif b = true then true
		      elseif self = null then null
		      elseif b = null then b
		      else false
		      endif
p. 

@implies2(b : Boolean[?]) : Boolean[?]@

@true@ if @self@ is @false@, or if @b@ is @true@.
Otherwise @false@.

bc.. 
body: if self = false then true
		      elseif b = true then true
		      else false
		      endif
p. 

@not() : Boolean[?] validating@
precedence: @UNARY@

@true@ if @self@ is @false@.
@false@ if @self@ is @true@.
@null@ if @self@ is @null@.
Otherwise @invalid@.

bc.. 
body: if self.oclIsInvalid() then self
		      elseif self = null then null
		      else self = false
		      endif
p. 

@not2() : Boolean[1]@

@true@ if @self@ is @false@.
Otherwise @false@.

bc.. 
body: if self then false else true endif
p. 

@or(b : Boolean[?]) : Boolean[?] invalidating validating@
precedence: @OR@

@true@ if either @self@ or @b@ is @true@.
Otherwise @invalid@ if either @self@ or @b@ is @invalid@.
Otherwise @null@ if either @self@ or @b@ is @null@.
Otherwise @false@.

bc.. 
body: if self.oclIsInvalid() then
		        if b.oclIsInvalid() then self
			    elseif b = true then true
		        else self
		        endif
		      elseif self = true then true
			  elseif b.oclIsInvalid() then b
			  elseif b = true then true
			  elseif self = null then null
			  elseif b = null then null
		      else false
		      endif
p. 

@or2(b : Boolean[?]) : Boolean[?]@

@true@ if either @self@ or @b@ is @true@.
Otherwise @false@.

bc.. 
body: if self = true then true
			  elseif b = true then true
		      else false
		      endif
p. 

@toString() : String[1]@

Converts @self@ to a string value.

@xor(b : Boolean[?]) : Boolean[?]@
precedence: @XOR@

@true@ if @self@ is @true@ and @b@ is @false@, or if @self@ is @false@ and @b@ is @true@.
@false@ if @self@ is @true@ and @b@ is @true@, or if @self@ is @false@ and @b@ is @false@.
Otherwise @invalid@ if either @self@ or @b@ is @invalid@.
Otherwise @null@.

bc.. 
body: if self.oclIsInvalid() then self
		      elseif b.oclIsInvalid() then b
		      elseif self = null then null
		      elseif b = null then null
		      else self <> b
		      endif
p. 

@xor2(b : Boolean[?]) : Boolean[?]@

@true@ if @self@ <> @b@
Otherwise @false@.

bc.. 
body: self <> b
p. 

h2(#Class). **@Class@**

conformsTo "@OclAny@":#OclAny

h2(#Collection). **@Collection(T)@**

Collection is the abstract supertype of all collection types in the OCL Standard Library.
Each occurrence of an object in a collection is called an element.
If an object occurs twice in a collection, there are two elements.

This sub clause defines the properties on Collections that have identical semantics for all collection subtypes.
Some operations may be defined within the subtype as well,
which means that there is an additional postcondition or a more specialized return value.
Collection is itself an instance of the metatype CollectionType.

The definition of several common operations is different for each subtype.
These operations are not mentioned in this sub clause.

The semantics of the collection operations is given in the form of a postcondition that uses the IterateExp of the IteratorExp construct.
The semantics of those constructs is defined in Clause 10 (“Semantics Described using UML”).
In several cases the postcondition refers to other collection operations,
which in turn are defined in terms of the IterateExp or IteratorExp constructs.

Well-formedness rules

 A collection cannot contain @invalid@ values.

context Collection
inv: self->forAll(not oclIsInvalid())

conformsTo "@OclAny@":#OclAny

*Attributes*

@lower : Integer[1]@

Evaluates to the lower bound on the number of collection elements.

@upper : Integer[1]@

Evaluates to the upper bound on the number of collection elements.

*Associations*

@elementType : T[1]@

Evaluates to the type of the collection elements.

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

True if c is a collection of the same kind as @self@ and contains the same elements in the same quantities and in the same order,
in the case of an ordered collection type.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

True if c is not equal to @self@.

@asBag() : Bag(T)@

The Bag that contains all the elements from @self@.

@asOrderedSet() : OrderedSet(T)@

An OrderedSet that contains all the elements from @self@, with duplicates removed,
in an order dependent on the particular concrete collection type.

@asSequence() : Sequence(T)@

A Sequence that contains all the elements from @self@, in an order dependent on the particular concrete collection type.

@asSet() : Set(T)@

The Set containing all the elements from @self@, with duplicates removed.

@count(object : OclAny[?]) : Integer[1]@

The number of times that object occurs in the collection @self@.

@excludes(object : OclAny[?]) : Boolean[1]@

True if object is not an element of @self@, @false@ otherwise.

@excludesAll(T2)(c2 : Collection(T2)) : Boolean[1]@

Does @self@ contain none of the elements of c2 ?

@excluding(object : OclAny[?]) : Collection(T)@

The collection containing all elements of @self@ apart from object.

@excludingAll(objects : Collection(OclAny)) : Collection(T)@

The collection containing all elements of @self@ apart from all occurrences of all objects.

@flatten(T2)() : Collection(T2)@

If the element type is not a collection type, this results in the same collection as @self@.
If the element type is a collection type, the result is a collection containing all the elements of all the recursively flattened elements of @self@.

@includes(object : OclAny[?]) : Boolean[1]@

True if object is an element of @self@, @false@ otherwise.

@includesAll(T2)(c2 : Collection(T2)) : Boolean[1]@

Does @self@ contain all the elements of c2 ?

@including(object : T[?]) : Collection(T)@

The collection containing all elements of @self@ plus object.

@includingAll(objects : Collection(T)) : Collection(T)@

The collection containing all elements of @self@ and objects.

@intersection(u : UniqueCollection(T)) : Set(T)@

The intersection of @self@ and a unique collection; the set of all elements that are in both @self@ and u.

@intersection(c : Collection(T)) : Bag(T)@

The intersection of @self@ and bag; the bag of all elements that are in both @self@ and c.

@isEmpty() : Boolean[1]@

Is @self@ the empty collection?

Note: @null->isEmpty()@ returns @true@ in virtue of the implicit casting from @null@ to @Bag{}@.

@max() : T[1]@

The element with the maximum value of all elements in @self@.
Elements must be of a type supporting the max operation.
The max operation - supported by the elements - must take one parameter of type T and be both associative and commutative.
UnlimitedNatural, Integer and Real fulfill this condition.

@min() : T[1]@

The element with the minimum value of all elements in @self@.
Elements must be of a type supporting the min operation.
The min operation - supported by the elements - must take one parameter of type T and be both associative and commutative.
UnlimitedNatural, Integer and Real fulfill this condition.

@notEmpty() : Boolean[1]@

Is @self@ not the empty collection?

@null->notEmpty()@ returns @false@ in virtue of the implicit casting from @null@ to @Bag{}@.

@product(T2)(c2 : Collection(T2)) : Set(Tuple(first:T[1], second:T2[1]))@

The cartesian product operation of @self@ and c2.

@selectByKind(TT)(type : TT[?]) : Collection(TT)@

@selectByType(TT)(type : TT[?]) : Collection(TT)@

@size() : Integer[1]@

The number of elements in the collection @self@.

@sum() : T[1]@

The addition of all elements in @self@.
Elements must be of an @OclSummable@ type to provide the zero() and sum() operations.
The _sum_ operation must be both associative: a.sum(b).sum(c) = a.sum(b.sum(c)), and commutative: a.sum(b) = b.sum(a).
Integer and Real fulfill this condition.

If the _sum_ operation is not both associative and commutative, the _sum_ expression is not well-formed,
which may result in unpredictable results during evaluation.
If an implementation is able to detect a lack of associativity or commutativity,
the implementation may bypass the evaluation and return an @invalid@ result.

@union(c : Collection(T)) : Bag(T)@

The bag consisting of all elements in @self@ and all elements in c.

*Iterations*

@any(i : T[?] | body : Lambda T() : Boolean[1]) : T[?]@

Returns any element in the _source_ collection for which _body_ evaluates to @true@.
Returns @invalid@ if the _body_ evaluates to @invalid@ for any element,
otherwise if there are one or more elements for which the _body_ is @true@,
an indeterminate choice of one of them is returned, otherwise the result is @invalid@.

let source : Collection(T) = ..., body : Lambda T() : Boolean = ... in
source->any(iterator | body) = source->select(iterator | body)->asSequence()->first()

@collect(V)(i : T[?] | lambda : Lambda T() : V[?]) : Collection(V)@

The Collection of elements that results from applying body to every member of the source set.
The result is flattened. Notice that this is based on collectNested, which can be of different type depending on the type of source.
collectNested is defined individually for each subclass of CollectionType.

@collectNested(V)(i : T[?] | lambda : Lambda T() : V[?]) : Collection(V)@

The Collection of elements which results from applying body to every member of the source collection.

@exists(i : T[?] | lambda : Lambda T() : Boolean[?]) : Boolean[?]@

Results in @true@ if body evaluates to @true@ for at least one element in the source collection.

@exists(i : T[?], j : T[?] | lambda : Lambda T() : Boolean[?]) : Boolean[?]@

@forAll(i : T[?] | lambda : Lambda T() : Boolean[?]) : Boolean[?]@

Results in @true@ if the body expression evaluates to @true@ for each element in the source collection; otherwise, result is @false@.

@forAll(i : T[?], j : T[?] | lambda : Lambda T() : Boolean[?]) : Boolean[?]@

@isUnique(i : T[?] | lambda : Lambda T() : OclAny[?]) : Boolean[1]@

Results in @true@ if body evaluates to a different value for each element in the source collection; otherwise, result is @false@.

@iterate(Tacc)(i : T[?]acc : ; Tacc[?] | lambda : Lambda T() : Tacc[?]) : Tacc[?]@

@one(i : T[?] | lambda : Lambda T() : Boolean[1]) : Boolean[1]@

Results in @true@ if there is exactly one element in the source collection for which body is @true@.

@reject(i : T[?] | lambda : Lambda T() : Boolean[1]) : Collection(T)@

The sub-collection of the source collection for which body is @false@.

@select(i : T[?] | lambda : Lambda T() : Boolean[1]) : Collection(T)@

The sub-collection of the source collection for which body is @true@.

@sortedBy(i : T[?] | lambda : Lambda T() : OclAny[?]) : Sequence(T)@

Results in the Collection containing all elements of the source collection.
The element for which body has the lowest value comes first, and so on.
The type of the body expression must have the < operation defined.
The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c then a < c).

h2(#Enumeration). **@Enumeration@**

@Deprecated: Use OclEnumeration
The Enumeration type is the type of an OrderedSet of EnumerationLiteral.

conformsTo "@OclAny@":#OclAny

*Attributes*

@allLiterals : OrderedSet(EnumerationLiteral)@

Evaluates to the literals of the enumeration.

*Operations*

@allInstances() : Set(OclSelf)@

Return a set of all enumeration values of @self@.

h2(#EnumerationLiteral). **@EnumerationLiteral@**

The standard type EnumerationLiteral represents a named constant value of an Enumeration.

conformsTo "@OclAny@":#OclAny

*Attributes*

@Enumeration : Bag(Enumeration[*|?])@

@OclEnumeration : Bag(OclEnumeration[*|?])@

h2(#Integer). **@Integer@**

The standard type Integer represents the mathematical concept of integer.
Integer is itself an instance of the metatype PrimitiveType (from UML).

conformsTo "@Real@":#Real

*Operations*

@*(i : OclSelf[?]) : Integer[1]@
precedence: @MULTIPLICATIVE@

The value of the multiplication of @self@ and i.

@+(i : OclSelf[?]) : Integer[1]@
precedence: @ADDITIVE@

The value of the addition of @self@ and i.

@-() : Integer[1]@
precedence: @UNARY@

The negative value of @self@.

@-(i : OclSelf[?]) : Integer[1]@
precedence: @ADDITIVE@

The value of the subtraction of i from @self@.

@/(i : OclSelf[?]) : Real[1] invalidating@
precedence: @MULTIPLICATIVE@

The value of @self@ divided by i.
Evaluates to @invalid@ if r is equal to zero.

@abs() : Integer[1]@

The absolute value of @self@.

@div(i : Integer[?]) : Integer[1]@

The number of times that i fits completely within @self@.

@max(i : OclSelf[?]) : Integer[1]@

The maximum of @self@ an i.

@min(i : OclSelf[?]) : Integer[1]@

The minimum of @self@ an i.

@mod(i : Integer[?]) : Integer[1]@

The result is @self@ modulo i.

@toString() : String[1]@

Converts @self@ to a string value.

@toUnlimitedNatural() : UnlimitedNatural[1]@

Converts a non-negative @self@ to an UnlimitedNatural value. A negative @self@ is converted to @invalid@.
An automatic coersion may be synthesized if the coercion enables an operation reference to be resolved
in an expression where no operation was available without coercion.

h2(#Map). **@Map(K, V)@**

A Map provides a Set of key values, each of which has an associated value.
Keys and values may be null, but neither may be invalid.

conformsTo "@OclAny@":#OclAny

*Associations*

@keyType : K[?]@

The key type of the key-value pairs of @self@.

@valueType : V[?]@

The value type of the key-value pairs of @self@.

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Evaluates to @true@ if @self@ and s contain the same elements.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@at(key : OclAny[?]) : V[?] invalidating@

The value of the map at @key@.

@excludes(key : OclAny[?]) : Boolean[1]@

True if @key@ is not one of the keys of @self@, @false@ otherwise.

@excludes(key : OclAny[?], value : OclAny[?]) : Boolean[1]@

True if @key@ and @value@ are not a key-value pair of @self@, @false@ otherwise.

@excludesAll(K2)(coll : Collection(K2)) : Boolean[1]@

True if none of the elements of @coll@ are keys of @self@, @false@ otherwise.

@excludesMap(K2, V2)(map : Map(K2, V2)[?]) : Boolean[1]@

True if none of the key-value pairs of @map@ are also key-value pairs of @self@, @false@ otherwise.

@excludesValue(value : OclAny[?]) : Boolean[1]@

True if @value@ is not one of the values of @self@, @false@ otherwise.

@excluding(key : OclAny[?]) : Map(K, V)[?]@

The map containing all key-value pairs of @self@ except any whose key is @key@.

@excluding(key : OclAny[?], value : OclAny[?]) : Map(K, V)[?]@

The map containing all key-value pairs of @self@ except any whose key is @key@ and whose value is @key@.

@excludingAll(keys : Collection(OclAny)) : Map(K, V)[?]@

The map containing all key-value pairs of @self@ except any whose key is included in @keys@.

@excludingMap(K2, V2)(map : Map(K2, V2)[?]) : Map(K, V)[?]@

The map containing all key-value pairs of @self@ except any which is also included in @map@.

@includes(key : OclAny[?]) : Boolean[1]@

True if @key@ is one of the keys of @self@, @false@ otherwise.

@includes(key : OclAny[?], value : OclAny[?]) : Boolean[1]@

True if @key@ and @value@ are a key-value pair of @self@, @false@ otherwise.

@includesAll(K2)(coll : Collection(K2)) : Boolean[1]@

True if all the elements of @coll@ are keys of @self@, @false@ otherwise.

@includesMap(K2, V2)(map : Map(K2, V2)[?]) : Boolean[1]@

True if all of the key-value pairs of @map@ are also key-value pairs of @self@, @false@ otherwise.

@includesValue(value : OclAny[?]) : Boolean[1]@

True if @value@ is one of the values of @self@, @false@ otherwise.

@including(key : K[?], value : V[?]) : Map(K, V)[?]@

The map containing all of the key-value pairs of @self@ and an additional key-value pair for @key@ and @value@.
If @key@ is already a key of @self@, the old value pair is replaced by @value@.

@includingMap(K2, V2)(map : Map(K2, V2)[?]) : Map(K, V)[?]@

The map containing all of the key-value pairs of @self@ and @map@.
The values associated with key-value pairs in @map@ replace those in @self@ where the same key is used by both maps.

@isEmpty() : Boolean[1]@

True if @self@ is the empty map, @false@ otherwise.

@keys() : Set(K)@

A Set comprising all the keys of the key-value pairs in @self@.

@notEmpty() : Boolean[1]@

True if @self@ not the empty map, @false@ otherwise.

@size() : Integer[1]@

The number of key-value pairs in @self@.

@values() : Bag(V)@

The Bag comprising all the values of the key-value pairs in @self@.

h2(#OclAny). **@OclAny@**

The number of elements in the collection @self@.essions.
OclAny is itself an instance of the metatype AnyType.

All classes in a UML model inherit all operations defined on OclAny.
To avoid name conflicts between properties in the model and the properties inherited from OclAny,
all names on the properties of OclAny start with ‘ocl.’
Although theoretically there may still be name conflicts, they can be avoided.
One can also use qualification by OclAny (name of the type) to explicitly refer to the OclAny properties.

Operations of OclAny, where the instance of OclAny is called object.

*Attributes*

@OclInvalid : Bag(OclInvalid[*|?])@

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

True if @self@ is the same object as object2. Infix operator.

bc.. 
post: result = self = object2
p. 

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

True if @self@ is a different object from object2. Infix operator.

bc.. 
post: result = not (self = object2)
p. 

@oclAsSet() : Set(OclSelf)@

Returns a Set with @self@ as the sole content, unless @self@ is @null@ in which case returns an empty set,

@oclAsType(TT)(type : TT[?]) : TT[1] invalidating@

Evaluates to @self@, where @self@ is of the type identified by @TT@.
The type @TT@ may be any classifier defined by OCL or a user metamodel;
if the actual type of @self@ at evaluation time does not conform to @TT@,
then the oclAsType operation evaluates to @invalid@.

If @self@ is a multiply classified instance, the current classification used for OCL navigation
is changed to the classification to which @TT@ conforms. The oclAsType call is not well-formed if
the classification is ambiguous.

In the case of feature redefinition, casting an object to a supertype of its actual type
does not access the supertype’s definition of the feature;
according to the semantics of redefinition, the redefined feature simply does not exist for the object.
However, when casting to a supertype, any features additionally defined by the subtype are suppressed.

bc.. 
post IsSelf: result = self
p. 

@oclIsInState(statespec : OclState[?]) : Boolean[1]@

Evaluates to @true@ if the @self@ is in the state identified by statespec.

@oclIsInvalid() : Boolean[1] validating@

Evaluates to @true@ if the @self@ is equal to OclInvalid.

@oclIsKindOf(type : OclType[?]) : Boolean[1]@

Evaluates to @true@ if the type of @self@ conforms to @type@.
That is, @self@ is of type @type@ or a subtype of @type@.

@oclIsNew() : Boolean[1]@

Can only be used in a postcondition.
Evaluates to @true@ if the @self@ is created during performing the operation (for instance, it didn’t exist at precondition time).

@oclIsTypeOf(type : OclType[?]) : Boolean[1]@

Evaluates to @true@ if @self@ is of the type @type@ but not a subtype of @type@.

@oclIsUndefined() : Boolean[1] validating@

Evaluates to @true@ if the @self@ is equal to @invalid@ or equal to @null@.

@oclLog() : OclSelf[?]@

Evaluates to the self, with the side effect of generating a log message comprising self.

@oclLog(message : String[?]) : OclSelf[?]@

Evaluates to the self, with the side effect of generating a log message comprising message followed by self.

@oclType() : OclSelf[1]@

Evaluates to the most derived type of which @self@ is currently an instance. If @self@ is an instance of a multiply
classified type, the return is the most derived type of the current classification which is established when the instance is
passed to OCL, or re-established by an @oclAsType()@ call.

@oclTypes() : Set(OclSelf[*|?])@

Evaluates to all of the most derived type of which @self@ is an instance. The return from @oclTypes()@
is normally equivalent to that from @oclType()@ unless @self@ is an instance of multiply classified type.

@toString() : String[1]@

Returns a string representation of @self@.

h2(#OclComparable). **@OclComparable@**

The type OclComparable defines the compareTo operation used by the sortedBy iteration. Only types that provide a derived
compareTo implementation may be sorted.

conformsTo "@OclAny@":#OclAny

*Operations*

@<(that : OclSelf[?]) : Boolean[1]@
precedence: @RELATIONAL@

True if @self@ is less than @that@.

@<=(that : OclSelf[?]) : Boolean[1]@
precedence: @RELATIONAL@

True if @self@ is less than or equal to @that@.

@>=(that : OclSelf[?]) : Boolean[1]@
precedence: @RELATIONAL@

True if @self@ is greater than or equal to @that@.

@>(that : OclSelf[?]) : Boolean[1]@
precedence: @RELATIONAL@

True if @self@ is greater than @that@.

@compareTo(that : OclSelf[?]) : Integer[1]@

Return -ve, 0, +ve according to whether self is less than, equal to , or greater than that.

The compareTo operation should be commutative.

h2(#OclElement). **@OclElement@**

The type OclElement is the implicit supertype of any user-defined type that has no explicit supertypes. Operations defined
for OclElement are therefore applicable to all user-defined types.

conformsTo "@OclAny@":#OclAny

*Attributes*

@OclElement : Bag(OclElement[*|?])@

@OclElement : Bag(OclElement[*|?])@

@oclContents : Set(OclElement)@

The composed contents of self.

*Associations*

@oclContainer : OclElement[?]@

The object for which self is a composed content or null if there is no such object.

*Operations*

@allInstances() : Set(OclSelf)@

Return a set of all instances of the type and derived types of self.

@oclAsModelType(TT)(type : TT[?]) : TT[1] invalidating@

Evaluates to @self@, where @self@ is of the model type identified by @TT@.

Most model elements have metamodel types for use with oclAsType, but no model type and so the return is @invalid@.

Model elements such as UML's InstnaceSpecification that do support distinct model and metamodel types return @self@
with the cast type @TT@ that may be used for further navigation.
If the actual model type of @self@ at evaluation time does not conform to @TT@,
then the oclAsType operation evaluates to @invalid@.

If @self@ is a multiply classified instance, the current classification used for OCL navigation
is changed to the classification to which @TT@ conforms. The oclAsModelType call is not well-formed if
the classification is ambiguous.

bc.. 
post IsSelf: result = self
p. 

@oclContainer() : OclElement[?]@

Returns the object for which self is a composed content or null if there is no such object.

@oclContents() : Set(OclElement)@

Returns the composed contents of self.

@oclIsModelKindOf(type : OclType[?]) : Boolean[1]@

Evaluates to @true@ if the type of @self@ conforms to the model type @type@.
That is, @self@ is of type @type@ or a subtype of @type@.

The return is normally @false@ since few model elements have model types. UML's InstanceSpecification::classifier provides
a multiple classification for a model type.

@oclModelType() : OclSelf[1]@

Evaluates to the most derived model type of which @self@ is currently an instance. If @self@ is an instance of a multiply
classified model type, the return is the most derived type of the current classification which is established
by an @oclAsModelType()@ call.

The return is normally @invalid@ since few model elements have model types. UML's InstanceSpecification::classifier provides
a multiple classification for a model type.

@oclModelTypes() : Set(OclSelf[*|?])@

Evaluates to all of the most derived model types of which @self@ is an instance. The return from @oclModelTypes()@
is normally equivalent to that from @oclModelType()@ unless @self@ is an instance of multiply classified model type.

The return is normally @invalid@ since few model elements have model types. UML's InstanceSpecification::classifier provides
a multiple classification for a model type.

h2(#OclEnumeration). **@OclEnumeration@**

The OclEnumeration type is the implicit supertype of any user Enumeration type.

conformsTo "@OclType@":#OclType

*Attributes*

@allLiterals : OrderedSet(EnumerationLiteral)@

Evaluates to the literals of the enumeration.

*Operations*

@allInstances() : Set(OclSelf)@

Return a set of all enumeration values of @self@.

h2(#OclInvalid). **@OclInvalid@**

The type OclInvalid is a type that conforms to all other types.
It has one single instance, identified as  @invalid@.
Any property call applied on invalid results in @invalid@, except for the operations oclIsUndefined() and oclIsInvalid().
OclInvalid is itself an instance of the metatype InvalidType.

conformsTo "@OclVoid@":#OclVoid

*Associations*

@oclBadProperty : OclAny[?]@

An oclBadProperty may be used as a placeholder in an unsuccessfully created OCLExpression.

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Returns @invalid@.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Returns @invalid@.

@allInstances() : Set(OclSelf)@

Returns @invalid@.

@and(b : Boolean[?]) : Boolean[?] validating@
precedence: @AND@

@implies(b : Boolean[?]) : Boolean[?] validating@
precedence: @IMPLIES@

@oclAsSet() : Set(OclSelf)@

@oclAsType(TT)(type : TT[?]) : TT[?]@

@oclBadOperation() : OclAny[?]@

An oclBadOperation may be used as a placeholder in an unsuccessfully created OCLExpression.

@oclIsInvalid() : Boolean[1] validating@

@oclIsKindOf(type : OclType[?]) : Boolean[1]@

@oclIsTypeOf(type : OclType[?]) : Boolean[1]@

@oclIsUndefined() : Boolean[1] validating@

@oclType() : OclSelf[1]@

@or(b : Boolean[?]) : Boolean[?] validating@
precedence: @OR@

@toString() : String[1]@

Returns 'invalid'.

h2(#OclLambda). **@OclLambda@**

The type OclLambda is the implicit supertype of all Lambda types. The operations defined for OclLambda
therefore apply to all lambda expressions.

conformsTo "@OclAny@":#OclAny

h2(#OclMessage). **@OclMessage@**

OclMessage
This sub clause contains the definition of the standard type OclMessage.
As defined in this sub clause, each ocl message type is actually a template type with one parameter.
‘T’ denotes the parameter.
A concrete ocl message type is created by substituting an operation or signal for the T.

The predefined type OclMessage is an instance of MessageType.
Every OclMessage is fully determined by either the operation, or signal given as parameter.
Note that there is conceptually an undefined (infinite) number of these types,
as each is determined by a different operation or signal.
These types are unnamed. Every type has as attributes the name of the operation or signal,
and either all formal parameters of the operation, or all attributes of the signal.
OclMessage is itself an instance of the metatype MessageType.

OclMessage has a number of predefined operations, as shown in the OCL Standard Library.

conformsTo "@OclAny@":#OclAny

*Operations*

@hasReturned() : Boolean[1]@

True if type of template parameter is an operation call, and the called operation has returned a value.
This implies the fact that the message has been sent. False in all other cases.

@isOperationCall() : Boolean[1]@

Returns @true@ if the OclMessage represents the sending of a UML Operation call.

@isSignalSent() : Boolean[1]@

Returns @true@ if the OclMessage represents the sending of a UML Signal.

@result() : OclAny[?]@

Returns the result of the called operation, if type of template parameter is an operation call,
and the called operation has returned a value. Otherwise the @invalid@ value is returned.

h2(#OclSelf). **@OclSelf@**

The pseudo-type OclSelf denotes the statically determinate type of @self@ in Operation
and Iteration signatures. Instances of OclSelf are never created.

conformsTo "@OclAny@":#OclAny

h2(#OclState). **@OclState@**

conformsTo "@OclAny@":#OclAny

h2(#OclStereotype). **@OclStereotype@**

The type OclStereotype is the implicit supertype of any UML stereotype. Operations defined
for OclStereotype are therefore applicable to all UML stereotypes.

conformsTo "@OclType@":#OclType

*Operations*

@allInstances() : Set(OclSelf)@

Return a set of all instances of the stereotype and derived types of self.

h2(#OclSummable). **@OclSummable@**

The type OclSummable defines the sum and zero operations used by the Collection::sum iteration. Only types that provide derived
sum and zero implementations may be summed.

conformsTo "@OclAny@":#OclAny

*Operations*

@sum(that : OclSelf[?]) : OclSelf[?]@

Return the sum of self and that.

The sum operation should be associative.

@zero() : OclSelf[?]@

Return the 'zero' value of self to initialize a summation.

zero().sum(self) = self.

h2(#OclTuple). **@OclTuple@**

The type OclTuple is the implicit supertype of all Tuple types. The operations defined for OclTuple
therefore apply to all tuples.

conformsTo "@OclAny@":#OclAny

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

h2(#OclType). **@OclType@**

The type OclType is the implicit supertype of any UML type. Operations defined
for OclType are therefore applicable to all UML types.

conformsTo "@OclElement@":#OclElement

*Operations*

@conformsTo(type2 : OclType[?]) : Boolean[1]@

Returns true if type2 conforms to self.

h2(#OclVoid). **@OclVoid@**

The type OclVoid is a type that conforms to all other types except OclInvalid.
It has one single instance, identified as @null@, that corresponds with the UML LiteralNull value specification.
Any property call applied on @null@ results in @invalid@, except for the
oclIsUndefined(), oclIsInvalid(), =(OclAny) and <>(OclAny) operations.
However, by virtue of the implicit conversion to a collection literal,
an expression evaluating to @null@ can be used as source of collection operations (such as ‘isEmpty’).
If the source is the @null@ literal, it is implicitly converted to Bag{}.

OclVoid is itself an instance of the metatype VoidType.

conformsTo "@OclAny@":#OclAny

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Redefines the OclAny operation, returning @true@ if object is @null@, @invalid@
if object is @invalid@, @false@ otherwise.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@allInstances() : Set(OclSelf[*|?])@

Returns @Set{null}@.

@and(b : Boolean[?]) : Boolean[?]@
precedence: @AND@

@implies(b : Boolean[?]) : Boolean[?]@
precedence: @IMPLIES@

@oclAsSet() : Set(OclSelf)@

@oclIsInvalid() : Boolean[1] validating@

@oclIsUndefined() : Boolean[1] validating@

@or(b : Boolean[?]) : Boolean[?]@
precedence: @OR@

@toString() : String[1]@

Returns @null@.

h2(#OrderedCollection). **@OrderedCollection(T)@**

The OrderedCollection type provides the shared functionality of the OrderedSet and Sequence
collections for which the elements are ordered.
The common supertype of OrderedCollection is Collection.

conformsTo "@Collection(T)@":#Collection

*Operations*

@at(index : Integer[?]) : T[?] invalidating@

The i-th element of ordered collection.

@first() : T[?] invalidating@

The first element in @self@.

@indexOf(obj : OclAny[?]) : Integer[1] invalidating@

The index of object obj in the ordered collection.

@last() : T[?] invalidating@

The last element in @self@.

h2(#OrderedSet). **@OrderedSet(T)@**

The OrderedSet is a Set, the elements of which are ordered.
It contains no duplicates. OrderedSet is itself an instance of the metatype OrderedSetType.
An OrderedSet is not a subtype of Set, neither a subtype of Sequence.
The common supertype of Sets and OrderedSets is Collection.

conformsTo "@OrderedCollection(T)@":#OrderedCollection, "@UniqueCollection(T)@":#UniqueCollection

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@-(s : UniqueCollection(OclAny)) : OrderedSet(T)@
precedence: @ADDITIVE@

The elements of @self@, which are not in s.

@append(object : T[?]) : OrderedSet(T)@

The set of elements, consisting of all elements of @self@, followed by object.

@appendAll(objects : OrderedCollection(T)) : OrderedSet(T)@

The set of elements, consisting of all elements of @self@, followed by objects.

@excluding(object : OclAny[?]) : OrderedSet(T)@

The ordered set  containing all elements of @self@ apart from object.

The order of the remaining elements is not changed.

@excludingAll(objects : Collection(OclAny)) : OrderedSet(T)@

The ordered set containing all elements of @self@ apart from all occurrences of all objects.

@flatten(T2)() : OrderedSet(T2)@

@including(object : T[?]) : OrderedSet(T)@

The ordered set containing all elements of @self@ plus object added as the last element if not already present.

@includingAll(objects : Collection(T)) : OrderedSet(T)@

The ordered set containing all elements of @self@ plus objects added as the last elements.

@insertAt(index : Integer[?], object : T[?]) : OrderedSet(T) invalidating@

The ordered set consisting of @self@ with object present at position index.

@prepend(object : T[?]) : OrderedSet(T)@

The sequence consisting of object, followed by all elements in @self@.

bc.. 
post IsAtStart: result->at(1) = object
p. 

bc.. 
post IsShiftedAlong: Sequence{1..self->size()}->forAll(index | self->at(index) = result->at(index + 1))
p. 

bc.. 
post IsSizePlusOne: result->size() = self->size() + 1
p. 

@prependAll(objects : OrderedCollection(T)) : OrderedSet(T)@

The sequence consisting of objects, followed by all elements in @self@.

@reverse() : OrderedSet(T)@

The ordered set of elements with same elements but with the opposite order.

@selectByKind(TT)(type : TT[?]) : OrderedSet(TT)@

@selectByType(TT)(type : TT[?]) : OrderedSet(TT)@

@subOrderedSet(lower : Integer[?], upper : Integer[?]) : OrderedSet(T) invalidating@

The sub-set of @self@ starting at number lower, up to and including element number upper.

*Iterations*

@closure(i : T[1] | lambda : Lambda T() : OrderedSet(T)[?]) : OrderedSet(T)@

The closure of applying body transitively to every distinct element of the source collection.

@collect(V)(i : T[?] | lambda : Lambda T() : V[?]) : Sequence(V)@

@collectNested(V)(i : T[?] | lambda : Lambda T() : V[?]) : Sequence(V)@

The sequence of elements that results from applying body to every member of the source ordered collection.

@reject(i : T[?] | lambda : Lambda T() : Boolean[1]) : OrderedSet(T)@

The ordered set of the source ordered set for which body is @false@.

@select(i : T[?] | lambda : Lambda T() : Boolean[1]) : OrderedSet(T)@

The ordered set of the source ordered set for which body is @true@

@sortedBy(i : T[?] | lambda : Lambda T() : OclAny[?]) : OrderedSet(T)@

Results in the ordered set containing all elements of the source collection.
The element for which body has the lowest value comes first, and so on.
The type of the body expression must have the < operation defined.
The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c, then a < c).

h2(#Real). **@Real@**

The standard type Real represents the mathematical concept of real.
Note that Integer is a subclass of Real,
so for each parameter of type Real, you can use an integer as the actual parameter.
Real is itself an instance of the metatype PrimitiveType (from UML).

conformsTo "@OclComparable@":#OclComparable, "@OclSummable@":#OclSummable

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Returns @true@ if the numeric value of @self@ is the same as the numeric value of object2, @false@ otherwise.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Returns @true@ if the numeric value of @self@ is the not the same as the numeric value of object2, @false@ otherwise.

@*(r : OclSelf[?]) : Real[1]@
precedence: @MULTIPLICATIVE@

The value of the multiplication of @self@ and r.

@+(r : OclSelf[?]) : Real[1]@
precedence: @ADDITIVE@

The value of the addition of @self@ and r.

@-() : Real[1]@
precedence: @UNARY@

The negative value of @self@.

@-(r : OclSelf[?]) : Real[1]@
precedence: @ADDITIVE@

The value of the subtraction of r from @self@.

@/(r : OclSelf[?]) : Real[1] invalidating@
precedence: @MULTIPLICATIVE@

The value of @self@ divided by r. Evaluates to @invalid@ if r is equal to zero.

@abs() : Real[1]@

The absolute value of @self@.

@floor() : Integer[1]@

The largest integer that is less than or equal to @self@.

@max(r : OclSelf[?]) : Real[1]@

The maximum of @self@ and r.

@min(r : OclSelf[?]) : Real[1]@

The minimum of @self@ and r.

@round() : Integer[1]@

The integer that is closest to @self@. When there are two such integers, the largest one.

@toString() : String[1]@

Converts @self@ to a string value.

h2(#Sequence). **@Sequence(T)@**

A sequence is a collection where the elements are ordered.
An element may be part of a sequence more than once.
Sequence is itself an instance of the metatype SequenceType.
A Sentence is not a subtype of Bag.
The common supertype of Sentence and Bags is Collection.

conformsTo "@OrderedCollection(T)@":#OrderedCollection

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

True if @self@ contains the same elements as s in the same order.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@append(object : T[?]) : Sequence(T)@

The sequence of elements, consisting of all elements of @self@, followed by object.

@appendAll(objects : OrderedCollection(T)) : Sequence(T)@

The sequence of elements, consisting of all elements of @self@, followed by objects.

@excluding(object : OclAny[?]) : Sequence(T)@

The sequence containing all elements of @self@ apart from all occurrences of object.

The order of the remaining elements is not changed.

@excludingAll(objects : Collection(OclAny)) : Sequence(T)@

The sequence containing all elements of @self@ apart from all occurrences of all objects.

@flatten(T2)() : Sequence(T2)@

Redefines the Collection operation. If the element type is not a collection type, this results in the same sequence as @self@.
If the element type is a collection type, the result is the sequence containing all the elements
of all the recursively flattened elements of @self@. The order of the elements is partial.

@including(object : T[?]) : Sequence(T)@

The sequence containing all elements of @self@ plus object added as the last element.

@includingAll(objects : Collection(T)) : Sequence(T)@

The sequence containing all elements of @self@ plus objects added as the last elements.

@insertAt(index : Integer[?], object : T[?]) : Sequence(T) invalidating@

The sequence consisting of @self@ with object inserted at position index.

@prepend(object : T[?]) : Sequence(T)@

The sequence consisting of object, followed by all elements in @self@.

@prependAll(objects : OrderedCollection(T)) : Sequence(T)@

The sequence consisting of objects, followed by all elements in @self@.

@reverse() : Sequence(T)@

The sequence containing the same elements but with the opposite order.

@selectByKind(TT)(type : TT[?]) : Sequence(TT)@

@selectByType(TT)(type : TT[?]) : Sequence(TT)@

@subSequence(lower : Integer[?], upper : Integer[?]) : Sequence(T) invalidating@

The sub-sequence of @self@ starting at number lower, up to and including element number upper.

*Iterations*

@closure(i : T[1] | lambda : Lambda T() : OrderedSet(T)[?]) : OrderedSet(T)@

The closure of applying body transitively to every distinct element of the source collection.

@collect(V)(i : T[?] | lambda : Lambda T() : V[?]) : Sequence(V)@

@collectNested(V)(i : T[?] | lambda : Lambda T() : V[?]) : Sequence(V)@

The sequence of elements that results from applying body to every member of the source ordered collection.

@reject(i : T[?] | lambda : Lambda T() : Boolean[1]) : Sequence(T)@

The subsequence of the source sequence for which body is @false@.

@select(i : T[?] | lambda : Lambda T() : Boolean[1]) : Sequence(T)@

The subsequence of the source sequence for which body is @true@.

@sortedBy(i : T[?] | lambda : Lambda T() : OclAny[?]) : Sequence(T)@

Results in the Sequence containing all elements of the source collection.
The element for which body has the lowest value comes first, and so on.
The type of the body expression must have the < operation defined.
The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c then a < c).

h2(#Set). **@Set(T)@**

conformsTo "@UniqueCollection(T)@":#UniqueCollection

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

Evaluates to @true@ if @self@ and s contain the same elements.

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@-(s : UniqueCollection(OclAny)) : Set(T)@
precedence: @ADDITIVE@

The elements of @self@, which are not in s.

@excluding(object : OclAny[?]) : Set(T)@

The set containing all elements of @self@ without object.

@excludingAll(objects : Collection(OclAny)) : Set(T)@

The set containing all elements of @self@ apart from all occurrences of all objects.

@flatten(T2)() : Set(T2)@

Redefines the Collection operation. If the element type is not a collection type, this results in the same set as @self@.
If the element type is a collection type, the result is the set containing all the elements of all the recursively flattened elements of @self@.

@including(object : T[?]) : Set(T)@

The set containing all elements of @self@ plus object.

@includingAll(objects : Collection(T)) : Set(T)@

The set containing all elements of @self@ and objects.

@selectByKind(TT)(type : TT[?]) : Set(TT)@

@selectByType(TT)(type : TT[?]) : Set(TT)@

*Iterations*

@closure(i : T[1] | lambda : Lambda T() : Set(T)[?]) : Set(T)@

The closure of applying body transitively to every distinct element of the source collection.

@collect(V)(i : T[?] | lambda : Lambda T() : V[?]) : Bag(V)@

@collectNested(V)(i : T[?] | lambda : Lambda T() : V[?]) : Bag(V)@

The Bag of elements which results from applying body to every member of the source nonordered collection.

@reject(i : T[?] | lambda : Lambda T() : Boolean[1]) : Set(T)@

The subset of the source set for which body is @false@.

@select(i : T[?] | lambda : Lambda T() : Boolean[1]) : Set(T)@

The subset of set for which expr is @true@.

@sortedBy(i : T[?] | lambda : Lambda T() : OclAny[?]) : OrderedSet(T)@

Results in the ordered set containing all elements of the source collection.
The element for which body has the lowest value comes first, and so on.
The type of the body expression must have the < operation defined.
The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c, then a < c).

h2(#State). **@State@**

conformsTo "@OclState@":#OclState

h2(#String). **@String@**

The standard type String represents strings, which can be both ASCII or Unicode.
String is itself an instance of the metatype PrimitiveType (from UML).

conformsTo "@OclComparable@":#OclComparable, "@OclSummable@":#OclSummable

*Operations*

@=(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@<>(object2 : OclSelf[?]) : Boolean[1]@
precedence: @EQUALITY@

@<(s : OclSelf[?]) : Boolean[1]@
precedence: @RELATIONAL@

True if @self@ is less than s, using the locale defined by looking up oclLocale in the current environment.

@<=(s : OclSelf[?]) : Boolean[1]@
precedence: @RELATIONAL@

True if @self@ is less than or equal to s, using the locale defined by looking up oclLocale in the current environment.

@>=(s : OclSelf[?]) : Boolean[1]@
precedence: @RELATIONAL@

True if @self@ is greater than or equal to s, using the locale defined by looking up oclLocale in the current environment.

@>(s : OclSelf[?]) : Boolean[1]@
precedence: @RELATIONAL@

True if @self@ is greater than s, using the locale defined by looking up oclLocale in the current environment.

@+(s : String[?]) : String[1]@
precedence: @ADDITIVE@

The concatenation of @self@ and s.

@at(i : Integer[?]) : String[1] invalidating@

Queries the character at position i in @self@.

@characters() : Sequence(String)@

Obtains the characters of @self@ as a sequence.

@compareTo(that : OclSelf[?]) : Integer[1]@

The comparison of @self@ with @that@. -ve if less than, 0 if equal, +ve if greater than.

@concat(s : String[?]) : String[1]@

The concatenation of @self@ and s.

@endsWith(s : String[?]) : Boolean[1]@

Returns true if @self@ ends with the string s.
Every string ends with the empty string.

@equalsIgnoreCase(s : String[?]) : Boolean[1]@

Queries whether s and @self@ are equivalent under case-insensitive collation.

@indexOf(s : String[?]) : Integer[1]@

Queries the first index in @self@ at which s is a substring of @self@, or zero if s is not a substring of @self@.
The empty string is a substring of every string at index 1 (and also at all other indexes).

@lastIndexOf(s : String[?]) : Integer[1]@

Queries the last in @self@ at which s is a substring of @self@, or zero if s is not a substring of @self@.
The empty string is a substring of every string at index @self@-size()+1 (and also at all other indexes).

@matches(regex : String[?]) : Boolean[1]@

Use a regular expression match and return true if self matches regex, false otherwise.

@replaceAll(regex : String[?], replacement : String[?]) : String[1] invalidating@

Return a string derived from self by replacing all matches of regex by replacement.

@replaceFirst(regex : String[?], replacement : String[?]) : String[1] invalidating@

Return a string derived from self by replacing the first match of regex by replacement.

@size() : Integer[1]@

The number of characters in @self@.

@startsWith(s : String[?]) : Boolean[1]@

Returns true if @self@ starts with the string s.
Every string starts with the empty string.

@substituteAll(oldSubstring : String[?], newSubstring : String[?]) : String[1]@

Return a string derived from self by replacing all occurrences of oldSubstring by newSubstring.

@substituteFirst(oldSubstring : String[?], newSubstring : String[?]) : String[1]@

Return a string derived from self by replacing the first occurrence of oldSubstring by newSubstring.
Returns invalid if there is no first occurrence.

@substring(lower : Integer[?], upper : Integer[?]) : String[1] invalidating@

The sub-string of @self@ starting at character number lower, up to and including character number upper. Character numbers run from 1 to self.size().

@toBoolean() : Boolean[1] invalidating@

Converts @self@ to a boolean value.

@toInteger() : Integer[1] invalidating@

Converts @self@ to an Integer value.

@toLower() : String[1]@

This is a deprecated variant of toLowerCase() preserving compatibility with traditional Eclipse OCL behaviour.

@toLowerCase() : String[1]@

Converts @self@ to lower case, using the locale defined by looking up oclLocale in the current environment.
Otherwise, returns the same string as @self@.

@toReal() : Real[1] invalidating@

Converts @self@ to a Real value.

@toString() : String[1]@

Returns @self@.

@toUpper() : String[1]@

This is a deprecated variant of toUpperCase() preserving compatibility with traditional Eclipse OCL behaviour.

@toUpperCase() : String[1]@

Converts @self@ to upper case, using the locale defined by looking up oclLocale in the current environment.
Otherwise, returns the same string as @self@.

@tokenize() : Sequence(String)@

Partition @self@ into a sequence substrings separated by any of space, line-feed, carriage-return, form-feed and horizontal-tab delimiters.
The delimiters are omitted from the return.

@tokenize(delimiters : String[?]) : Sequence(String)@

Partition @self@ into a sequence substrings separated by characters in the delimiters. The delimiters are omitted from the return.

@tokenize(delimiters : String[?], returnDelimiters : Boolean[?]) : Sequence(String)@

Partition @self@ into a sequence substrings separated by characters in the delimiters. If returnDelimeters is
true the returned sequence includes the delimiters, otherwise the delimiters are omitted.

@trim() : String[1]@

Return @self@ with leading and trailing whitespace removed.

h2(#Type). **@Type@**

The UML Type is the supertype of anything that may be used as a type.

conformsTo "@OclType@":#OclType

*Operations*

@conformsTo(type2 : Type[?]) : Boolean[1]@

Returns true if type2 conforms to self.

h2(#UniqueCollection). **@UniqueCollection(T)@**

The UniqueCollection type provides the shared functionality of the OrderedSet and Set
collections for which the elements are unique.
The common supertype of UniqueCollection is Collection.

conformsTo "@Collection(T)@":#Collection

*Operations*

@-(s : UniqueCollection(OclAny)) : UniqueCollection(T)@
precedence: @ADDITIVE@

The elements of @self@, which are not in s.

@intersection(c : Collection(T)) : Set(T)@

The intersection of @self@ and c (i.e., the set of all elements that are in both @self@ and c).

@symmetricDifference(s : UniqueCollection(OclAny)) : Set(T)@

The set containing all the elements that are in @self@ or s, but not in both.

@union(s : UniqueCollection(T)) : Set(T)@

The set consisting of all elements in @self@ and all elements in s.

*Iterations*

@sortedBy(i : T[?] | lambda : Lambda T() : OclAny[?]) : OrderedSet(T)@

Results in the ordered set containing all elements of the source collection.
The element for which body has the lowest value comes first, and so on.
The type of the body expression must have the < operation defined.
The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c, then a < c).

h2(#UnlimitedNatural). **@UnlimitedNatural@**

The standard type UnlimitedNatural is used to encode the non-negative values of a multiplicity specification.
This includes a special _unlimited_ value (*) that encodes the upper value of  a multiplicity specification.
UnlimitedNatural is itself an instance of the metatype UnlimitedNaturalType.

Note that UnlimitedNatural is not a subclass of Integer.

conformsTo "@OclComparable@":#OclComparable

*Operations*

@max(i : OclSelf[?]) : UnlimitedNatural[1]@

The maximum of @self@ an i.

@min(i : OclSelf[?]) : UnlimitedNatural[1]@

The minimum of @self@ an i.

@oclAsType(TT)(type : TT[?]) : TT[?] invalidating@

Evaluates to @self@, where @self@ is of the type identified by T.
The type T may be any classifier defined in the UML model;
if the actual type of @self@ at evaluation time does not conform to T,
then the oclAsType operation evaluates to @invalid@.

The standard behavior is redefined for UnlimitedNatural. Numeric values may be converted to
Real or Integer, but the _unlimited_ value may not.
Conversion of _unlimited_ to Real or Integer returns @invalid@.


@toInteger() : Integer[1] invalidating@

Converts @self@ to an Integer value unless @self@ is _unlimited_ in which case @self@ is converted to @invalid@.
